  private fun undo() {
        val edit = editHistory.getPrevious() ?: return
        val text = binding.txtEntry.editableText
        val start = edit.start
        val end = start + if (edit.after != null) edit.after.length else 0

        skipTextWatch = true
        text.replace(start,end,edit.before)
        skipTextWatch = false

        binding.txtEntry.setSelection(if(edit.before == null) start else start + edit.before.length)
    }

    private fun redo() {
        val edit = editHistory.getNext() ?: return
        val text = binding.txtEntry.editableText
        val start = edit.start
        val end = start + if (edit.before != null) edit.before.length else 0

        skipTextWatch = true
        text.replace(start,end,edit.after)
        skipTextWatch = false

        binding.txtEntry.setSelection(if(edit.after == null) start else start + edit.after.length)
    }

private var textWatcher: CustomTextWatcher = object : CustomTextWatcher() {
        override fun beforeTextChanged(
            s: CharSequence,
            start: Int,
            count: Int,
            after: Int,
        ) {
            if(!skipTextWatch) {
                beforeChange = s.subSequence(start, start + count)
            }
        }

        override fun onTextChanged(
            s: CharSequence,
            start: Int,
            before: Int,
            count: Int,
        ) {
            if(!skipTextWatch) {
                afterChange = s.subSequence(start, start + count)
                editHistory.add(EditHistoryItem(start, beforeChange!!, afterChange!!))
            }
        }

        override fun afterTextChanged(p0: Editable?) {
            setUndoRedoButtons(
                editHistory.position > 1,
                editHistory.position < editHistory.history.size
            )
        }
    }
